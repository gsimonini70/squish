#!/bin/sh
### BEGIN INIT INFO
# Provides:          squish
# Required-Start:    $local_fs $network $remote_fs
# Required-Stop:     $local_fs $network $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Squish PDF Compression Engine
# Description:       High-performance PDF compression pipeline
### END INIT INFO

# ============================================
# Squish - SysV Init Script
# ============================================
# For systems without systemd (RHEL/CentOS 6, etc.)
#
# Installation:
#   cp squish.init /etc/init.d/squish
#   chmod +x /etc/init.d/squish
#   chkconfig --add squish      # RHEL/CentOS
#   update-rc.d squish defaults # Debian/Ubuntu

NAME=squish
DESC="Squish PDF Compression Engine"
APP_HOME=/opt/squish
JAR_FILE=$APP_HOME/squish.jar
PID_FILE=$APP_HOME/squish.pid
LOG_FILE=$APP_HOME/logs/squish.log
USER=squish

# Source function library (RHEL/CentOS)
if [ -f /etc/rc.d/init.d/functions ]; then
    . /etc/rc.d/init.d/functions
fi

# Source LSB functions (Debian/Ubuntu)
if [ -f /lib/lsb/init-functions ]; then
    . /lib/lsb/init-functions
fi

# Load environment files (in order of priority)
# 1. Application config (primary)
if [ -f $APP_HOME/config/squish.env ]; then
    . $APP_HOME/config/squish.env
fi
# 2. System config (override)
if [ -f /etc/sysconfig/squish ]; then
    . /etc/sysconfig/squish
elif [ -f /etc/default/squish ]; then
    . /etc/default/squish
fi

# Java configuration (defaults if not set in env files)
JAVA_HOME=${JAVA_HOME:-/usr/lib/jvm/java-22}
JAVA_OPTS=${JAVA_OPTS:-"-Xms512m -Xmx4g"}
SPRING_PROFILE=${SPRING_PROFILES_ACTIVE:-prod}

JAVA=$JAVA_HOME/bin/java

check_java() {
    if [ ! -x "$JAVA" ]; then
        echo "ERROR: Java not found at $JAVA"
        echo "Set JAVA_HOME environment variable"
        exit 1
    fi
}

start() {
    check_java

    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            echo "$NAME is already running (PID: $PID)"
            return 1
        fi
    fi

    echo "Starting $DESC..."

    # Ensure logs directory exists
    mkdir -p "$APP_HOME/logs"
    chown $USER:$USER "$APP_HOME/logs" 2>/dev/null

    cd "$APP_HOME" || exit 1
    
    # Export all configuration variables for Spring Boot to read from environment
    # This avoids exposing sensitive data in process list (ps aux)
    export SPRING_PROFILES_ACTIVE="${SPRING_PROFILE:-prod}"

    # Database
    [ -n "$DB_URL" ] && export DB_URL
    [ -n "$DB_USER" ] && export DB_USER
    [ -n "$DB_PASSWORD" ] && export DB_PASSWORD

    # Compression
    [ -n "$COMPRESSION_MODE" ] && export COMPRESSION_MODE
    [ -n "$DRY_RUN" ] && export DRY_RUN

    # Pipeline
    [ -n "$WORKER_THREADS" ] && export WORKER_THREADS
    [ -n "$ID_FROM" ] && export ID_FROM
    [ -n "$ID_TO" ] && export ID_TO

    # Query Configuration
    [ -n "$MASTER_TABLE" ] && export MASTER_TABLE
    [ -n "$DETAIL_TABLE" ] && export DETAIL_TABLE
    [ -n "$TRACKING_TABLE" ] && export TRACKING_TABLE
    [ -n "$ID_COLUMN" ] && export ID_COLUMN
    [ -n "$FILENAME_COLUMN" ] && export FILENAME_COLUMN
    [ -n "$DETAIL_ID_COLUMN" ] && export DETAIL_ID_COLUMN
    [ -n "$DATA_COLUMN" ] && export DATA_COLUMN
    [ -n "$MASTER_TABLE_FILTER" ] && export MASTER_TABLE_FILTER

    # Watchdog
    [ -n "$WATCHDOG_ENABLED" ] && export WATCHDOG_ENABLED
    [ -n "$WATCHDOG_INTERVAL" ] && export WATCHDOG_INTERVAL

    # Report
    [ -n "$REPORT_ENABLED" ] && export REPORT_ENABLED
    [ -n "$REPORT_DIRECTORY" ] && export REPORT_DIRECTORY

    # Email
    [ -n "$EMAIL_ENABLED" ] && export EMAIL_ENABLED
    [ -n "$SMTP_HOST" ] && export SMTP_HOST
    [ -n "$SMTP_PORT" ] && export SMTP_PORT
    [ -n "$SMTP_USER" ] && export SMTP_USER
    [ -n "$SMTP_PASSWORD" ] && export SMTP_PASSWORD
    [ -n "$SMTP_SSL" ] && export SMTP_SSL
    [ -n "$SMTP_STARTTLS" ] && export SMTP_STARTTLS
    [ -n "$SMTP_SSL_PROTOCOLS" ] && export SMTP_SSL_PROTOCOLS
    [ -n "$SMTP_FROM" ] && export SMTP_FROM
    [ -n "$SMTP_TO" ] && export SMTP_TO

    # HTTP/HTTPS
    [ -n "$HTTP_PORT" ] && export HTTP_PORT
    [ -n "$HTTP_SSL_ENABLED" ] && export HTTP_SSL_ENABLED
    [ -n "$HTTP_KEYSTORE_PATH" ] && export HTTP_KEYSTORE_PATH
    [ -n "$HTTP_KEYSTORE_PASSWORD" ] && export HTTP_KEYSTORE_PASSWORD
    [ -n "$HTTP_KEYSTORE_TYPE" ] && export HTTP_KEYSTORE_TYPE
    [ -n "$HTTP_SSL_PROTOCOL" ] && export HTTP_SSL_PROTOCOL

    echo "Starting $DESC with profile: $SPRING_PROFILES_ACTIVE"

    # Write environment to temp file for su to source (with export statements)
    ENV_FILE="$APP_HOME/.squish_env_$$"
    : > "$ENV_FILE"
    chmod 600 "$ENV_FILE"

    # Export each variable properly quoted (escape single quotes)
    for var in SPRING_PROFILES_ACTIVE DB_URL DB_USER DB_PASSWORD \
               COMPRESSION_MODE DRY_RUN WORKER_THREADS ID_FROM ID_TO \
               MASTER_TABLE DETAIL_TABLE TRACKING_TABLE ID_COLUMN \
               FILENAME_COLUMN DETAIL_ID_COLUMN DATA_COLUMN MASTER_TABLE_FILTER \
               WATCHDOG_ENABLED WATCHDOG_INTERVAL REPORT_ENABLED REPORT_DIRECTORY \
               EMAIL_ENABLED SMTP_HOST SMTP_PORT SMTP_USER SMTP_PASSWORD \
               SMTP_SSL SMTP_STARTTLS SMTP_SSL_PROTOCOLS SMTP_FROM SMTP_TO \
               HTTP_PORT HTTP_SSL_ENABLED HTTP_KEYSTORE_PATH HTTP_KEYSTORE_PASSWORD \
               HTTP_KEYSTORE_TYPE HTTP_SSL_PROTOCOL JAVA_HOME JAVA_OPTS; do
        eval "val=\"\$$var\""
        if [ -n "$val" ]; then
            # Escape single quotes: ' -> '\''
            escaped_val=$(printf '%s' "$val" | sed "s/'/'\\\\''/g")
            printf "export %s='%s'\n" "$var" "$escaped_val" >> "$ENV_FILE"
        fi
    done

    if [ -n "$USER" ]; then
        su -s /bin/sh "$USER" -c ". $ENV_FILE && nohup $JAVA $JAVA_OPTS -jar $JAR_FILE >> $LOG_FILE 2>&1 & echo \$! > $PID_FILE"
    else
        . "$ENV_FILE"
        nohup $JAVA $JAVA_OPTS -jar $JAR_FILE >> $LOG_FILE 2>&1 &
        echo $! > "$PID_FILE"
    fi

    rm -f "$ENV_FILE"
    
    sleep 3
    
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            echo "$NAME started (PID: $PID)"
            return 0
        fi
    fi
    
    echo "ERROR: Failed to start $NAME"
    return 1
}

stop() {
    if [ ! -f "$PID_FILE" ]; then
        echo "$NAME is not running"
        return 0
    fi
    
    PID=$(cat "$PID_FILE")
    
    if ! ps -p "$PID" > /dev/null 2>&1; then
        echo "$NAME is not running (stale PID file)"
        rm -f "$PID_FILE"
        return 0
    fi
    
    echo "Stopping $DESC (PID: $PID)..."
    kill "$PID"
    
    COUNT=0
    while [ $COUNT -lt 60 ]; do
        if ! ps -p "$PID" > /dev/null 2>&1; then
            break
        fi
        sleep 1
        COUNT=$((COUNT + 1))
    done
    
    if ps -p "$PID" > /dev/null 2>&1; then
        echo "Force killing..."
        kill -9 "$PID"
    fi
    
    rm -f "$PID_FILE"
    echo "$NAME stopped"
}

status() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            echo "$NAME is running (PID: $PID)"
            return 0
        fi
    fi
    echo "$NAME is not running"
    return 3
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart|reload)
        stop
        sleep 2
        start
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac

exit $?
